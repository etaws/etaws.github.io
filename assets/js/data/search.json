[ { "title": "Pin", "url": "/posts/pin-notes/", "categories": "编程", "tags": "rust, pin", "date": "2022-03-25 07:00:00 +0800", "snippet": "Pin 机制最重要的用途就是用来保证 Rust 异步机制的安全。本文深入介绍 Pin 的细节。注意：本文面向有 Rust 基础，学习过 Rust 指针的用法，Rust 异步的用法，但对 Pin 机制不了解的读者。一. 可移动进入本节之前，对 【move】 的概念进行回顾： 「变量」（variable）拥有「值」（value）；对复合数据结构，所有权可以是「树状结构」 move：把「值」的所有权转移给另外一个「变量」（owner）（类似 C 语言中的「浅拷贝」） 赋值（=），传递「函数参数」，返回「函数返回值」都会发生 move 一旦某个「变量」的所有权转移（move）走了以后，该「变量」失效，不能再使用这个「变量」 例如：在【函数】和【闭包】中，在入参是 move 的场景（而不是 borrow 的场景），进入函数后，参数和返回值的 owner 关系发生改变，原先的变量不再有效 不过有例外的情况：可以通过实现 Copy trait 把默认的 move 改成 copy（复制，所谓的深拷贝） Rust 中，一些简单类型，默认实现了 Copy trait，这些类型统称为 Copy Type Copy trait 继承了 Clone trait 用一个例子再详解一下 move 的细节：#![allow(unused)]fn main() { // s1 (变量) 是 String `hello` (值) 的 owner // 底层的实现大概是：`hello` 被存放在分配在 heap 上的空间 // s1 是个肥指针：记录了「字符串长度」，「字符串存放空间地址」等信息 let s1 = String::from(&quot;hello&quot;); // 进行 move：s1 记录的信息被 copy 给了 s2（「字符串长度」，「字符串存放空间地址」） // 但字符串内容（`hello`）本身地址不会变动 // 移动以后可以使用 s2 完全没有问题 // 这是因为 String `hello` 本身的地址没有变化，可以通过 s2 被安全的继续使用 let s2 = s1;}上面例子中的 s1 move 到 s2 具体动作如下图（从 TRPL 书摘录）所示：就上面的例子来说，String 类型是一个「可移动」（movable）类型。 可移动（movable）：所谓一个类型「可移动」，是指一旦拿到这个类型的「值」的 ownership 或 &amp;amp;mut（独占指针），并进行 move 操作，而不会引起问题（不会发生未定义行为）正常来说，就像上面的 String 类型，Rust 中的所有类型都应该是「可移动」的。但有例外的场景，某些类型被移动后，会有问题。比如对 Self-Referential Structs（自引用 structs）类型进行 move 就可能引起问题（发生未定义行为）。举个 Self-Referential Structs 的例子（一个字段指向另外一个字段）：struct Test { a: String, b: *const String,}自引用 structs 的 move 问题的细节请参考：Pinning in Detail，看了它里面的图就一目了然了：总之 Self-Referential Structs 可能会引起 move 后的指针无效问题。该问题可能的解决方法有： 每次 move 时，修改指针指向的地址；但这个方法会影响运行时的性能，代价较高 指针不储存绝对地址，只储存偏移量；这样需要编译器针对 Self-Referential Structs 做专门的处理，编译器的实现会比较复杂 Rust 采用 Pin 机制来解决问题：开发者负责把不能被 move 的类型标记出来；利用类型系统对这些被标记了的类型进行限制：使得没有办法对这些类型做 move 动作 运行时付出的代价为 0，不影响性能 代价就是开发者需要学习 Pin 的用法 二. Pin 的定义 核心理念： 要限制一个类型 T 不能被 move，也就是要对这个类型 T 的访问进行限制：只要不能拿到到这个类型 T 的 ownership 或者 &amp;amp;mut T（独占指针），也就不能对这个类型 T 做 move 操作。 在 Pin 机制中，只要利用 Pin 把这个类型 T 包起来（或者说屏蔽起来）就能实现这个限制效果。Pin 的定义：// 一个包了指针的 structpub struct Pin&amp;lt;P&amp;gt; { pointer: P,}其中： Pin 自己是一个指针，Pin 本身实现了 Deref 和 DerefMut， P 必须是一个指针，也就是实现了 Deref 或 DerefMut 的类型。例如：Box&amp;lt;T&amp;gt;怎么利用 Pin 把需要限制的类型 T 包起来（屏蔽起来）？ 因为 P 只能包一个指针，所以先要构建一个指向 T 的指针 P。可以构建 2 种指针： &amp;amp;mut T：「可变引用」实际上就是 T 的「独占指针」 Box&amp;lt;T&amp;gt;：使用智能指针 Box 然后再用 Pin 把构建好的指针类型 P 包起来。既然有 2 种指针，那么也有 2 种 Pin： Pin&amp;lt;&amp;amp;mut T&amp;gt;：但这种坑多，使用起来需要很小心，先不推荐使用这种 Pin Pin&amp;lt;Box&amp;lt;T»：可以使用标准库 Box::pin 函数来构建。得到一个在 heap 上的 T 的值，然后这个值被 Pin 屏蔽住，重点推荐使用这种 Pin 三. Unpin and !Unpin上一节已经说明了通过 Pin 机制，可以把「不可移动」的类型 T 封装到 Pin 中，这样就没有办法获取到 T 的 ownership 或者 &amp;amp;mut T（独占指针），进而保证不能对 T 进行 move。但实际上 Pin 是和 Unpin trait 组合在一起使用的，所以还需要详细介绍 Unpin（以及 !Unpin）的概念。 Unpin trait 是一种 auto trait。简单点说，Rust 中的各种类型，要么实现了 Unpin，要么实现了 !Unpin（事实上，Rust 中大多数类型都已经默认实现了 Unpin trait）。配合 Unpin 和 !Unpin，Pin 的使用原则如下：【原则一】： Unpin Types can be safely moved after being pinned。 如果类型 T 是「可移动」类型，那么需要给该类型 T 实现 Unpin trait。 一旦类型 T 实现了 Unpin trait，那么即使用 Pin 包住这个类型 T（例如 Pin&amp;lt;&amp;amp;mut T&amp;gt;），也不会对 T 有屏蔽效果。 依旧可以从 Pin 中拿到 T 的 ownership 或者 &amp;amp;mut T（独占指针），并进行 move。【原则二】： Guarantee that an object implementing !Unpin won’t ever be moved。 只有当 Pin 包住的类型 T（例如 Pin&amp;lt;Box&amp;lt;T» 中的 T）实现了 !Unpin trait，才无法获取到 T 的 ownership 或者 &amp;amp;mut T（独占指针），从而达到了对 T 的屏蔽效果，没办法对类型 T 进行 move。【原则三】： 一个 struct 类型 T 只要有一个 field 是 !Unpin 的，这个 struct 类型 T 就是 !Unpin 的。而 Rust 中绝大多数正常类型，都是「可移动」的，默认都已经实现了 Unpin。比如 String 类型，也已经默认实现了 Unpin。按照上面的【原则一】，即使被 Pin 包住，也不会并屏蔽，可以使用多种方法从 Pin 中拿到 String 进行操作:#![allow(unused)]fn main() { let mut string = &quot;Pinned?&quot;.to_string(); // 构建 Pin&amp;lt;&amp;amp;mut T&amp;gt; let mut pinned: Pin&amp;lt;&amp;amp;mut String&amp;gt; = Pin::new(&amp;amp;mut string); // String 实现了 Unpin，所以不会被 Pin 屏蔽 // 可以直接从 Pin&amp;lt;&amp;amp;mut T&amp;gt; 拿到内部真正的 T String，进行操作 pinned.push_str(&quot; Not&quot;); // 也提供了 Pin::into_inner 方法来返回指针 P（相当于可以把外层包的 Pin 去掉） Pin::into_inner(pinned).push_str(&quot; so much.&quot;); // 可成功进行 move let new_home = string; assert_eq!(new_home, &quot;Pinned? Not so much.&quot;);} NOTE： 甚至 Pin（一个 struct 类型）本身也自动实现了 Unpin。 利用 Pin 来限制「不可移动」的 T（T 需要实现 !Unpin），但 Pin 本身并没有实现 !Unpin 的必要。在 Rust 中，真正实现了 !Unpin trait 的只有 2 个类型（这里只先提一下，下一节会详细讲）： Future 转换为状态机时，编译器生成 Self-Referential Structs 来保存状态机上下文数据，编译器会给这些 Self-Referential Structs 实现 !Unpin trait 标准库中的 std::marker::PhantomPinned 类型也实现了 !Unpin trait四. Future and Pin Rust 里面，使用 Future 来描述一个状态机 编译器把 async fn 或 async block 转换为状态机代码时，使用到了 Self-Referential Structs 后续使用该 Future 的人如果不小心对这个 Future 进行了 move，就会出问题（引起「未定义行为」） 所以需要使用 Pin 机制来保证 Future 的安全（不会被 move）先简单举例说明怎么把异步代码（async fn 或 async block）转换为状态机（更多细节请参考：The Async/Await Pattern）。这里举个 async block 的简单例子：#![allow(unused)]fn main() { async { let mut x = [0; 128]; let read_into_buf_fut = read_into_buf(&amp;amp;mut x); read_into_buf_fut.await; println!(&quot;{:?}&quot;, x) }}编译器对这个 async block 生成状态机： 构建一个有 3 个状态的状态机：StartState，WaitingOnReadState，EndState 对每个状态，需要定义对应的 struct 来保存该状态的上下文信息：// 整个 async block 被转换为一个 future： struct AsyncFuture { // future 中包括了 async block 内部使用到的数据： x: [u8; 128], // future 中也需要包含状态机工作时，每个状态的上下文信息（只有记录了每个状态的上下文信息，状态机才能被不断推进） // 本例子中，我们只重点关心 WaitingOnReadState 状态的上下文 waiting_on_read_state: WaitingOnReadState,}// 定义一个 WaitingOnReadState 状态的上下文信息的 structstruct WaitingOnReadState&amp;lt;&#39;a&amp;gt; { // 指向了 AsyncFuture 的 `x` 字段，所以 AsyncFuture 是一个 Self-Referential Struct buf: &amp;amp;&#39;a mut [u8],}可以看出，async block 的状态机的底层实现中，会把 Future 实现为 Self-Referential Structs（自引用 struct），只能利用 Pin 机制来防止使用 Future 的人对 Future 进行 move。五. 进阶内容本节深入更多 Future 和 Pin 的工作细节，有兴趣的可以看看（主要是参考了 Pin and suffering 的内容，也可以直接去看原文）。Future trait 真实定义如下：#![allow(unused)]fn main() { use std::pin::Pin; use std::task::{Context, Poll}; pub trait Future { type Output; fn poll(self: Pin&amp;lt;&amp;amp;mut Self&amp;gt;, cx: &amp;amp;mut Context) -&amp;gt; Poll&amp;lt;Self::Output&amp;gt;; }}详解： Output 是 Future 执行完成后返回的值的类型 开始调用 poll() 方法之前，必须先用一个 Pin 类型把 Future 包装起来才能调用 poll() 方法 用一个 Pin 类型把 Future 包装起来的目的是防止这个 Future 实例被 move 由第 3 方异步运行时库提供的 Executor 负责执行 Future： 整个状态机由一个最外层 Future，和其它内部 Futures 一起组成 Executor 先做第一次 poll，启动状态机 Executor 会继续调用 poll，推进状态机，直到整个任务完成 但如果 Executor 通过循环重试的方式来不断 poll 效率太低。高效的方式是通过某种通知机制，当 Future 已经就绪时，才去做 poll。所以又引入了 Waker： 当 Executor 调用 poll 的时候需要提供一个 Context 参数，这个 Context 参数就包含了 Waker 未来当 Future 完成时，可以获取到 Waker（waker = cx.waker()），然后调用 waker.wake() 来通知 Executor 执行 poll 具体 waker.wake() 要怎么通知，由 Executor 实现： 一种可能的实现，就是调用 wake() 把就绪的任务加到就绪队列，Executor 消费就绪队列中已完成任务，进行 poll 实现要保证线程安全 先展示一个简单的，不断 wake Executor 做 poll 的例子：use std::{ future::Future, pin::Pin, task::{Context, Poll},};// 这个例子中，我们使用 tokio 作为运行时来执行 Future#[tokio::main]async fn main() { let fut = MyFuture {}; println!(&quot;Awaiting fut...&quot;); fut.await; println!(&quot;Awaiting fut... done!&quot;);}// 声明一个自己的 Futurestruct MyFuture {}// 实现 Future traitimpl Future for MyFuture { // 该 Future 返回 () type Output = (); fn poll(self: Pin&amp;lt;&amp;amp;mut Self&amp;gt;, cx: &amp;amp;mut Context&amp;lt;&#39;_&amp;gt;) -&amp;gt; Poll&amp;lt;Self::Output&amp;gt; { println!(&quot;MyFuture::poll()&quot;); // 如果没有 wake_by_ref() 的话，poll 就只会被调用一次 // 现在加上了 wake_by_ref()，每次 poll 时，会再次通知 Executor 进行下一次 poll，Executor 会再次调用 poll cx.waker().wake_by_ref(); // 但该例子中，无论 poll 多少次都返回 Pending，不会返回 Ready：无限次调用 poll Poll::Pending }}执行以后的无限次 poll 的效果如下：$ cargo run --quietAwaiting fut...MyFuture::poll()MyFuture::poll()MyFuture::poll()MyFuture::poll()MyFuture::poll()MyFuture::poll()MyFuture::poll()MyFutur^C然后再展示一个例子：启动一秒以后，能返回 Ready 的 Future：use tokio::time::Sleep;use tokio::time::Duration;use std::{ future::Future, pin::Pin, task::{Context, Poll},};#[tokio::main]async fn main() { let fut = MyFuture::new(); println!(&quot;Awaiting fut...&quot;); fut.await; println!(&quot;Awaiting fut... done!&quot;);}struct MyFuture { // Sleep 是一个 Future，不能直接调用 poll()， // 需要 Pin 和 Box 组合起来才能调用 poll（下面一个小节会详细说） sleep: Pin&amp;lt;Box&amp;lt;Sleep&amp;gt;&amp;gt;,}impl MyFuture { fn new() -&amp;gt; Self { Self { // 使用 tokio 异步版本的 sleep // Box::pin 创建一个 Pin&amp;lt;Box&amp;lt;T&amp;gt;，如果 T 没有实现 Unpin 的话，Pin 成功 // 本例子 Pin&amp;lt;Box&amp;lt;Sleep&amp;gt;&amp;gt; 中的 Sleep 类型就是没有实现 Unpin 的类型 sleep: Box::pin(tokio::time::sleep(Duration::from_secs(1))), } }}impl Future for MyFuture { type Output = (); fn poll(mut self: Pin&amp;lt;&amp;amp;mut Self&amp;gt;, cx: &amp;amp;mut Context&amp;lt;&#39;_&amp;gt;) -&amp;gt; Poll&amp;lt;Self::Output&amp;gt; { println!(&quot;MyFuture::poll()&quot;); // 这个一个典型的惯用法：Future 的实现里面对另外一个 Future 进行 poll // // 因为异步版本的 sleep 内部实现了利用 waker 来通知 Executor // 所以可以直接对异步版本的 sleep 进行 poll // // 异步版本的 sleep 的 poll()，需要 Pin 和 Box 组合起来调用 poll() self.sleep.as_mut().poll(cx) }}执行效果如下：$ cargo run --quietAwaiting fut...MyFuture::poll()这里会卡 1 秒MyFuture::poll()Awaiting fut... done! 另外一个之前例子没有覆盖的 Future 内部实现细节：每次 Executor 调用 poll 时，都会传入一个的 waker 参数；poll 的内部需要判断这次的 waker 和之前 poll 被调用时传入的 waker 的值是否匹配。代码大概如下：fn main() { // 获取原先的 waker let mut waker = waker.lock().unwrap(); // 判断原先的 waker 和本次调用传入的 waker 是否匹配 if !waker.will_wake(cx.waker()) { // 如果不匹配，需要 clone 本次传入的值，并记录到 Future 内部 *waker = cx.waker().clone(); }}" }, { "title": "制作咖啡", "url": "/posts/coff-notes/", "categories": "咖啡", "tags": "coffee", "date": "2022-03-24 19:04:00 +0800", "snippet": "一. 利用「聪明杯」制作咖啡1. 方法一 把咖啡豆磨成「咖啡粉」。粒度大概类似「白糖」的粒度； 水用 90 度左右的水； 折叠好滤纸，放入「聪明杯」，并打湿滤纸； 先放入「咖啡粉」； 再倒入水； 等待 3 分半的时间； 开阀门，等待过滤完成；2. 方法二 把咖啡豆（大概 13 克左右）磨成「咖啡粉」。粒度大概类似「白糖」的粒度； 水用 90 摄氏度左右的水； 折叠好滤纸，放入「聪明杯」，并打湿滤纸； 先倒入水； 再放入「咖啡粉」； 等待 4 分钟的时间； 开阀门，等待过滤完成；" }, { "title": "拍摄视频", "url": "/posts/video-notes/", "categories": "摄影", "tags": "video", "date": "2022-03-23 09:00:00 +0800", "snippet": "重点： 镜头运动 景别 焦距/景深 摄像机角度（眼平，低，高。。。） Framing（过肩，单人，双人，POV。。。）一. 基本镜头运动 原则 通过镜头运动来进行表达是重要的。通过反复观看影片中最有感染力的片段来分析并学习镜头的运动。 【重要】：场景序列不能有任何间断，不能让被拍摄的人物的联接中断（也就是镜头运动不能脱离演员） 基本镜头动作 Locked Off（镜头锁定）。通过静止的镜头来表达情绪 Pan, Left or Right（左右摇）。类似人类头部的转动（可能向右转表达乐观的情绪，向左转代表负面情绪） Slide, Left or Right（左右横移） Tilt, Up or Down（上下摇）。类似人类的抬头、低头 Boom, Up or Down（上下平移）。升上去，降下来 Zoom, In or Out（焦距拉伸）。注意和【镜头推拉】的区别 Push In or Pull Out（推拉） Push In：表达情绪的联接 二. 镜头景别 中景镜头（Medium Shot）：从腰部到头顶部 观众沉浸式体验 七分镜头（Cowboy Shot）：从大腿中部（枪套偏下一点）到头顶部 实际上时 Medium Shot 的变种 " }, { "title": "Poker", "url": "/posts/poker-notes/", "categories": "扑克", "tags": "poker", "date": "2022-03-22 09:00:00 +0800", "snippet": "名词解释 策略（Strategy） 在每种给定的条件下，玩家对应的采用对应的行动 纯策略 vs. 混合策略：在给定的条件下，如果采用纯策略，就总是采用相同的行动；而如果采用混合策略，在给定的条件下，会采用不同的行动； 均衡（Equilibrium） 当多个玩家达到均衡状态后，只有单个玩家改变策略不可能提升其收益 但并不排除多个玩家同时改变策略后可以提升他们的收益 胜率（Equity） 针对一手牌，或者一个确定的范围，在当所有玩家都不再下注以后，获胜的概率 用来评估牌力。例如：AKo 对抗 KK 的话，有 30% 的 Equity 期望值（Expected Value，EV） 计算期望值的时候，要考虑到未来所有玩家可能的行动 平衡（Indifference） 如果对一个玩家来说，从几个策略中选择具体哪一个，EV 都是一样的，那么这几个策略对这个玩家来说是平衡的 例如，我【下注】以后，对手玩家无论是【跟注】还是【弃牌】的 EV 都是一样的，那么我的这个【下注】对手玩家来说是【平衡】（Indifference）的 极化范围 vs. 紧缩范围 Polarized Ranges Consist of Strong and Weak Hands 翻译：极化范围只由强牌和弱牌组成。不包含中等牌，要么「坚果」要么「空气」（nut or air） 极化范围时，意味着主动下注（bet or raise）。越极化，下注额越大 Condensed Ranges Consist of Medium-Strength Hands 翻译：紧缩范围由中等牌组成 紧缩范围中的牌会输给强牌，赢弱牌。所以也就做抓诈范围（bluff-catching range） The Clairvoyance Game：一个用来展示极化范围和紧缩范围理论的 Toy Game（简化游戏）。游戏规则如下： 3 张牌 A/K/Q 发给 2 个玩家：OOP（Out of Position）和 IP（In Position） OOP 拿到的牌永远是 K；IP 拿到的牌要么是 A，要么是 Q IP 是「极化范围」 OOP 是「紧缩范围」 双方在下注前先各投入 $1（antes is $1） OOP 首先行动。他有 2 个选择：bet $1，或者 check IP 随后行动。分 2 种情况： 如果 OOP 之前的行动是 bet，IP 可以选择 call 或 fold 如果 OOP 之前的行动是 check，IP 可以选择 bet 或 check 每个玩家在面对对方的下注（bet）时，可以选择跟注（call），或者弃牌（fold）；但不能加注（raise） 如果选择 call，翻牌比大小，赢家获得池子中的所有筹码 如果选择 fold，对方获得池子中的所有筹码 Clairvoyance Game 的解决： 双方的 Equity 都是 50% 但如果双方达成了均衡（Equilibrium），IP 的 EV 大于 OOP 的 EV（也就是说，IP 可以赢更多的钱） IP 能赢钱的原因在于他的范围是「极化范围」，而 OOP 的范围是「紧缩范围」 OOP 首先的行动策略（OOP 的牌永远是 K）：check 当 OOP 首先的行动是 check 时，IP 的行动策略是「混合策略」。其整体的 bluff 频率为 1/4，平均 4 次下注中有 3 次是 A，1 次是 Q。也就是： IP 的牌是 A 的话，总是 bet IP 的牌是 Q 的话，摸到 3 次 Q，随机 bet 其中的 1 次 当 IP 的行动是 bet 时，OOP 的行动策略是「混合策略」。其整体的跟注频率是 2/3 才能达到「平衡」(Indifference)，平均 3 次里面跟注 2 次。为什么？请看下面的说明： 因为此时 IP 下注是「投 1 赢 3」 如果 OOP 的跟注频率小于 2/3，IP 就可以用任意的牌下注，这样的话，IP 下注的收益就高于「投 1 赢 3」 如果 OOP 的跟注频率大于 2/3，IP 就可以只用 A 下注，这样的话，IP 下注的收益也高于「投 1 赢 3」相同范围间的对抗如果不是上一节的「极化」对「紧缩」的场景，而是双方的范围相同的场景会发生什么？我们通过 Clairvoyance Game 的 2 个变种游戏来说明。 「变种一」：其他方面和 Clairvoyance Game 一样，除了 2 个变化点： OOP 不再只能拿到 K，而是 OOP 和 IP 都可以随机获得 A，K，Q 中的一张 OOP 最先一次被强制只能 check 「变种一」的解决： 双方的 Equity 都是 50% IP 拿到 K 时的策略是 check IP 拿到 A 和 Q 的行动策略是「混合策略」。其整体的 bluff 频率为 1/4，平均 4 次下注中有 3 次是 A，1 次是 Q。也就是： IP 的牌是 A 的话，总是 bet IP 的牌是 Q 的话，摸到 3 次 Q，随机 bet 其中的 1 次 分析如下： 当 OOP 面对 IP 的 bet 时，OOP 的跟注范围是：{A，K}，同时其跟注频率是 2/3 而如果 OOP 只用 A 跟注，那么这个策略的跟注频率只有 1/2，不满足 2/3 的要求。所以 OOP 需要用一定比例的 K 来跟注 既然 OOP 有用 K 来跟注的概率，IP 就有用 Q 来 bluff 的空间；而 bluff 频率和 Clairvoyance Game 一致：摸到 3 次 Q，随机 bet 其中的 1 次（bet 所有的 A） 通过「变种一」问题的解决，也总结出一个结论：当我们考虑 Bluff 的频率时，考虑的不是对方是否有比我大的牌；而是应该考虑对方拿到 nuts 牌的概率 「变种一」中，当 IP bet 时，OOP 用 K call 的频率是多少？ 考虑这个问题时，其实是先考虑 OOP 在 {A，K} 范围上，整体 call 的频率。整体上 call 的频率是 2/3（4/6），其中拿到 A 的时候是无脑 call 的；而拿到 A 的频率是 3/6，那么需要用 K call 来填充剩余的 1/6 的频率：拿到 K 的整体频率是 1/2，那么 1/6 除以 1/2 = 1/3，也就是每拿到 3 次 K，需要 call 一次（当 OOP 面对 IP bet 的时候） 如何计算 IP 的整体 EV？($0+$1+$2.17)/3 = $1.06（每投入 $1，能赢 6 分钱）。细节如下： 当 IP 拿到 Q 时，IP 的 EV 是 $0。IP check 时 EV 为 $0；IP bet，OOP 用均衡的策略应对，IP 的 EV 同样为 $0 当 IP 拿到 K 时，IP 的 EV 是 $1。IP 总是 check，进入 showdown，50% 赢 $2，50% $0，平均 EV 为 $1 当 IP 拿到 A 时，IP 的 EV 是 $2.17。IP 总是 bet，OOP 在 {K，Q} 的范围上所有的 Q 都不 call，K call 1/3，EV = 5/6*$2 + 1/6*$3=$2.17 「变种一」中，如果 IP 的 bet size 不是 $1，而是 $2（也就是 IP 从压 1 赢 3 变成了压 2 赢 4），IP 能赢更多钱么？ 答案是不能，IP 的盈利反而降低 因为，OOP 在 {A，K} 范围上面对 bet 时，A 时 call，K 时弃牌就能保证均衡；此时，双方的 EV 都是 $0 「变种二」：其他方面和「变种一」相同，除了 OOP 玩家可以先做 bet 这样 IP 唯一的优势就只有「位置」优势了 「变种二」的解决： IP 的 EV 比 OOP 的 EV 高（来源于位置优势） 如果 OOP 玩家 check，IP 玩家是否采用和「变种一」相同的行动策略？ 答案：相同；IP 依然可以针对 OOP 的 K 进行 bluff OOP 拿到 K 时只会做 check，我们重点讨论 OOP 用范围 {A，Q} 对抗 IP 的范围 {A，K，Q} OOP 现在可以先行动，当他拿到 A 时可以采用什么均衡策略？ 如果拿到 A 时 check，OOP 的盈利来源于 IP 用 Q 做 bluff 如果拿到 A 时 bet，OOP 的盈利来源于 IP 用 K 做 call 因此，OOP 用 A 做 check 还是 bet，要看 IP 愿意用 K 做 call，还是愿意用 Q 做 bluff 上一节已经计算过了，OOP 用 A 下注的整体 EV 是 $2.17 当 OOP 用 A check 时，IP 用所有的 A 下注，用所有的 K check，用 1/3 的 Q 做 bluff。这样可以计算得到 OOP 用 A check 时，OOP 整体的 EV 是：$2 * 5/6 + $3 * 1/6 = $2.17 从上面的计算可以得出结论，如果 IP 采用均衡的策略，OOP 用 A bet 和 用 A check 的 EV 也就平衡的 但如果 IP 的策略不均衡，OOP 就可以从用 A bet 和用 A check 中，选择盈利更多的一种来行动 简单小节 盈利来源于让对手处在「左右为难」的处境中，让其「进退两难」。例如：Clairvoyance Game 中，利用「极化范围」向对手进行施压，让他无法做出完美的选择 所谓的 Poker 「智慧」就是通过 bet，把对手放到一种「被考验」的场景中，让其「进退两难」 从「变种二」，我们也可以看到，当拿到最强牌时，也可以把 check 和 bet 混合起来，让对手难于做出选择：是否要 bluff 当处于范围劣势（紧缩范围）或者位置劣势（OOP）时，损失是不可避免的，所以这个时候的目标是把损失减少到最小 但是当面对人类对手时，可以考虑他的行动倾向，然后根据他的行动倾向来行动 在「变种二」，IP 在同一把牌中，可以把他的最强牌作为 bluff-catches 和 value bet；而 OOP 玩家在一把牌中，只能二选一，把最强牌要么用作 bluff-catches，要么用作 value-bet。这个就是 IP 玩家「位置优势」的来源 对「位置优势」的解释通常是「信息优势」，但从这个例子来看，IP 玩家未必只有「信息优势」 实战原理 只是通过简化的实战模型来说明原理， 先假设 flop 上只能 check 或者 bet 50% pot； 在 turn 上，只能 bet 50% 或 200%； 在 river 上，只能 bet 75% 或 200%； 除此之外，还假设 OOP 的玩家在 river 上，可以 bet 33%。 UTG 加注，BB 跟注；flop：As9h6s 双方谁的 Equity 比较高？UTG vs. BB 的话，UTG 的牌更强，Equity 更高 在这个 flop 上，双方谁更可能是「极化范围」？UTG 是「极化范围」 所以这里 BB 应该 check 在这个 flop 上，BB check 之后，UTG 怎么行动（check 或者 下注 50%）？ 下注尺度越大，代表程度更大的「极化范围」。如果能 33% 下注，可以用全范围下注；但这里只能是 50% 下注，所以不可能全范围下注，反而是很多牌要做 check：大的口袋对（例如 KK）、踢脚小的顶对（例如：A + 小牌） 另外，拿到 AA 时，也可以选择不下注，check；留给 BB 一些 bluff 的空间 如果 BB 在 flop 上做了 check &amp;amp; call，在 turn 上 BB 准备是继续 check？还是做 bet？应该是继续 check 在 turn 上的什么牌会使得 BB 从「紧缩范围」转移为「极化范围」，从而使得 BB 在 turn 上做 bet？ 简单数学 Odds：如果胜率是 33%（1/3），那么对应的 Odds 是：1:2（3 次里面，赢 1 次，输 2 次） Pot odds：底池里面有 7500，对手下注 2500；那么我需要投入 2500 去争取获得 12500；那么当前的 Pot odds 是：2500/12500 = 1/5（20%） Odds &amp;amp; Pot odds：如果 Pot odds 比当前牌面的 Odds 划算，那么此时下注的话，是「正 EV」的动作；否则，是「负 EV」的动作 Implied odds：计算 Pot odds 时只考虑当前下注轮次；但由于 Poker 不止一轮下注，所以如果预计能在未来的轮次能赢得更多，可以在计算 Pot odds 时把未来能赢到的钱加进来得到：Implied odds Outs 数：Outs 就是在等的牌，一旦真的等到 Outs 来了以后就赢了。Outs 不止一张，需要计算当前的 Outs 数，从而计算出「成牌概率」 2 &amp;amp; 4 法则 规则解析1. 摊牌顺序摊牌顺序：河牌圈所有人完成下注后的「摊牌顺序」（Order for revealing hands when showdown） Players are encouraged to show their cards promptly to avoid delaying the game, but if there is any reluctance, they are required to show them in clockwise order, beginning with the last player who bet or raised in the last betting round, or with the player who began the last betting round if everyone checked 翻译：最好是所有的 Player 都主动摊牌比大小，节约时间；但如果有人不愿意先摊牌的话，可以按顺时针顺序摊牌，而第一个摊牌的人是：在河牌圈最后一个 bet 或 raise 的 Player；但如果河牌圈所有人都 check，那么从河牌圈第一个需要行动的人开始摊牌 不过如果你确认你拿到的是「坚果」牌，最好是主动快速亮牌（出于礼貌），不然对手可能会不爽2. 有效加注有效加注:「有效加注」就是你选择加注时的最少需要投入的筹码量。其规则如下： 如果是本轮第一个下注的玩家，那么「有效下注」至少是 1 个大盲 如果本轮有其他玩家下注过了，那么「有效加注」的增量不得小于前一个有效下注的增量例如： 本轮下注顺序是这样的： A 玩家： 2bb B 玩家： 5bb C 玩家：这个时候的「有效加注」就至少是 8bb，因为 B 玩家 的下注的增量是 3bb，所以 C 玩家也至少要增加 3bb 如果这个时候 C 玩家只剩 7bb，那么他可以做 Allin。 在 C 玩家 Allin 之后，其他人弃牌到 A 玩家这里，A 玩家是可以继续做 raise 的，此时，A 玩家最少需要 raise 到（7bb + 3bb）= 10bb，因为 A 玩家下注之后 B 玩家进行过有效下注； 但是如果 A 玩家选择 call，那么 B 玩家不能继续下注了，因为 B 玩家下注之后只有 C 玩家进行过一个无效的下注，此时，B 玩家要么 call，要么 fold；3. AnteAnte（底注）：在发牌之前，除了 SB 和 BB 位置要分别投入大小盲注之外，还需要每个玩家投入相同的额度的筹码到底池，也就是 Ante（底注）。例如：小盲 100，大盲 200，Ante 25 （100/200/25）的意思就是：发牌前，SB 位下注 100，BB 位下注 200，其它每个玩家下注 25；如果有 6 位玩家，那么发牌前底池里面有：100 + 200 + 6 * 25 = 450。常见的 Ante 大小是每人给 1 个小盲。一般来说，Ante 的玩法有几种变化： 所有玩家的 Ante 由 BB 位置的玩家来给；例如：100/200/25 级别，6位玩家的话，BB 位置除了投入 200 大盲，还需要投入 150（6 * 25 = 150）Ante，BB 位置一共要投入 350 所有玩家的 Ante 由 BB 位置的玩家来给，但无论玩家有几位，Ante 数额不变。例如 100/200/200 的意思是：无论多少位玩家，BB 位置需要投入 200 大盲和 200 Ante，一共要投入 4004. StraddleStraddle（抓）：在发牌前，某个玩家可以声明（自愿）下 Straddle 注，大小必须是大盲注的 2 倍。同时，在翻前，做了 Straddle 下注的玩家最后一个行动。例如：100/200 的牌局，枪口位置的玩家进行 Straddle 下注：400；随后其他玩家依次行动，最后他在大盲注玩家行动以后再行动。" }, { "title": "Jekyll-Chirpy notes", "url": "/posts/Jekyll-Chirpy-notes/", "categories": "备忘", "tags": "jekyll, chirpy", "date": "2022-03-21 13:23:32 +0800", "snippet": "Just a Note.Please flow this guild: https://chirpy.cotes.page." } ]
